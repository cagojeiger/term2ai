# 아키텍처 개요

## 시스템 아키텍처

term2ai 터미널 래퍼는 기존 터미널 애플리케이션과의 호환성을 유지하면서 터미널 I/O 작업에 대한 완전한 제어를 제공하는 모듈식, 확장 가능한 시스템으로 설계되었습니다.

### 핵심 구성요소

```
┌─────────────────────────────────────────────────────────────┐
│               사용자 인터페이스 계층 (blessed)                   │
├─────────────────────────────────────────────────────────────┤
│  전역 입력 하이재킹 (keyboard + pynput)  │  플러그인 시스템     │
├─────────────────────────────────────────────────────────────┤
│  세션 관리자  │  AI 통합      │  네트워크 계층     │
├─────────────────────────────────────────────────────────────┤
│  ANSI 파서   │  시그널 관리자  │  필터 시스템      │
├─────────────────────────────────────────────────────────────┤
│  터미널 상태  │  I/O 관리자    │  버퍼 관리자      │
├─────────────────────────────────────────────────────────────┤
│              PTY 래퍼 코어 (ptyprocess + blessed)             │
├─────────────────────────────────────────────────────────────┤
│                   운영 체제 (Unix)                            │
└─────────────────────────────────────────────────────────────┘
```

### 하이재킹 아키텍처

term2ai는 **다층 하이재킹 아키텍처**를 통해 터미널 I/O의 완전한 제어를 달성합니다:

```
Level 3: GUI 터미널 제어 (blessed)
         ├─ 전체 화면 모드
         ├─ 고급 커서 제어  
         ├─ 터미널 기능 감지
         └─ ANSI 시퀀스 최적화
         ↓
Level 2: 전역 입력 하이재킹 (keyboard + pynput)
         ├─ 시스템 레벨 키보드 캡처
         ├─ 마우스 이벤트 모니터링
         ├─ 글로벌 단축키 처리
         └─ 백그라운드 입력 감시
         ↓
Level 1: PTY 기반 하이재킹 (ptyprocess + pexpect)
         ├─ 터미널 세션 완전 제어
         ├─ 입출력 스트림 인터셉션
         ├─ 프로세스 생명주기 관리
         └─ ANSI 이스케이프 시퀀스 캡처
         ↓
Level 0: 운영 체제 (Unix)
         ├─ PTY 디바이스 제어
         ├─ 시그널 처리
         ├─ 파일 디스크립터 관리
         └─ 프로세스 그룹 제어
```

### 계층 설명

#### PTY 래퍼 코어 (Level 1)
- **목적**: 기본적인 의사 터미널 작업 및 blessed 통합
- **구성요소**: 프로세스 생성, 기본 I/O, 리소스 관리, 터미널 제어
- **의존성**: ptyprocess, pexpect, blessed
- **하이재킹 기능**: 터미널 세션 내부 완전 제어

#### 전역 입력 하이재킹 계층 (Level 2)
- **목적**: 시스템 레벨 입력 캡처 및 모니터링
- **구성요소**: 키보드 Hook, 마우스 이벤트, 글로벌 단축키, 백그라운드 감시
- **의존성**: keyboard, pynput
- **하이재킹 기능**: PTY 외부 모든 입력 이벤트 캡처

#### 터미널 상태 및 I/O 관리
- **목적**: 고급 I/O 처리 및 터미널 상태 추적
- **구성요소**: 비동기 I/O, 버퍼링, 터미널 모드, 커서 추적
- **의존성**: asyncio, termios, blessed
- **하이재킹 기능**: 모든 I/O 스트림 인터셉션 및 분석

#### 처리 계층
- **목적**: 데이터 처리 및 터미널 제어
- **구성요소**: ANSI 파싱, 시그널 처리, 데이터 필터링
- **의존성**: blessed (ANSI 최적화), 핵심 터미널 기능
- **하이재킹 기능**: 모든 ANSI 이스케이프 시퀀스 가로채기

#### 기능 계층
- **목적**: 고급 기능 및 통합
- **구성요소**: 세션 기록, AI 통합, 네트워크 기능
- **의존성**: 처리 계층 구성요소
- **하이재킹 기능**: 캡처된 데이터의 실시간 분석 및 활용

#### 플러그인 시스템
- **목적**: 확장성 및 사용자 정의
- **구성요소**: 플러그인 로딩, API, 생명주기 관리
- **의존성**: 모든 하위 계층
- **하이재킹 기능**: 하이재킹된 데이터에 대한 사용자 정의 처리

#### 사용자 인터페이스 계층 (Level 3)
- **목적**: 고급 터미널 제어 및 사용자 상호작용
- **구성요소**: 전체 화면 모드, 고급 커서 제어, CLI, 설정, 모니터링
- **의존성**: blessed, rich, typer
- **하이재킹 기능**: 터미널 화면 완전 제어

## 데이터 흐름

### 하이재킹 입력 흐름
```
물리적 키보드/마우스 → 전역 입력 하이재킹 (keyboard/pynput) → 
입력 분석 & 로깅 → UI 계층 (blessed) → 플러그인 필터 → 
세션 기록 → ANSI 처리 → 터미널 상태 → PTY 코어 → 셸 프로세스
```

### 하이재킹 출력 흐름
```
셸 프로세스 → PTY 코어 → 버퍼 관리 → ANSI 파싱 (blessed 최적화) → 
출력 하이재킹 & 분석 → 필터 시스템 → 세션 기록 → 
플러그인 처리 → UI 표시 (blessed 제어)
```

### 완전 하이재킹 루프
```
┌─── 전역 입력 모니터링 (Level 2) ───┐
│                                    │
▼                                    │
물리적 입력 → 하이재킹 캡처 → 분석   │
│                                    │
▼                                    │
PTY 세션 (Level 1) → 출력 캡처 → 분석
│                                    │
▼                                    │
터미널 화면 (Level 3) → 화면 제어 ───┘
```

## 주요 설계 원칙

### 1. 모듈성
- 각 구성요소는 명확하고 잘 정의된 책임을 가짐
- 구성요소는 정의된 인터페이스를 통해 통신
- 개별 구성요소를 쉽게 테스트, 유지보수, 확장

### 2. 확장성
- 플러그인 시스템은 핵심 변경 없이 사용자 정의 기능 허용
- 필터 아키텍처는 데이터 처리 사용자 정의 가능
- 설정 시스템은 다양한 배포 시나리오 지원

### 3. 성능
- 반응형 작업을 위한 비동기 I/O
- 효율적인 버퍼링 및 메모리 관리
- 고처리량 시나리오를 위한 최적화된 파싱 알고리즘

### 4. 호환성
- 기존 터미널 애플리케이션과의 호환성 유지
- 다양한 터미널 유형 및 기능 지원
- 지원되지 않는 기능에 대한 우아한 성능 저하

### 5. 타입 안전성
- 코드베이스 전체에 포괄적인 타입 힌트
- 데이터 검증 및 직렬화를 위한 Pydantic 모델
- mypy를 사용한 정적 타입 검사

### 6. 리소스 안전성 (RAII 패턴)
- Context manager를 통한 자동 리소스 관리
- 예외 발생 시에도 보장되는 리소스 정리
- RAII (Resource Acquisition Is Initialization) 원칙 준수
- 메모리 누수 및 파일 디스크립터 누수 방지

## 구성요소 상호작용

### PTY 래퍼 코어
- 셸 프로세스 생성 및 관리
- 기본 읽기/쓰기 작업 제공
- 프로세스 생명주기 및 정리 처리
- Context manager를 통한 자동 리소스 정리

### I/O 관리자
- **aiofiles 기반 비동기 파일 I/O**: 세션 로깅, 설정 파일 처리
- **uvloop 성능 최적화**: Unix 계열에서 2-4배 성능 향상 (조건부 활성화)
- **입출력 버퍼 관리**: 8KB 기본 버퍼, 적응적 크기 조정
- **I/O 멀티플렉싱**: select/epoll을 통한 동시 스트림 처리
- **aiosignal 통합**: 비동기 시그널 처리와 I/O 작업 조정
- **Async context manager**: 비동기 리소스 자동 관리 (__aenter__/__aexit__)
- **Unix 전용 최적화**: epoll/kqueue 기반 최적 I/O 성능

### 터미널 상태 관리자
- 터미널 모드 및 기능 추적
- 창 크기 및 커서 위치 관리
- 터미널 상태 변경 처리

### ANSI 파서
- ANSI 이스케이프 시퀀스 파싱
- 시퀀스를 구조화된 데이터로 변환
- 색상 코드 및 제어 명령 처리

### 시그널 관리자
- 시스템 시그널 가로채기 및 처리
- 자식 프로세스로 시그널 전파
- 시그널 안전 작업 관리

### 세션 관리자
- 터미널 세션 기록
- 세션 재생 기능 제공
- 세션 지속성 관리
- Context manager를 통한 세션 생명주기 자동 관리

### 플러그인 시스템
- 플러그인을 동적으로 로드 및 관리
- 플러그인 개발을 위한 API 제공
- 플러그인 생명주기 및 의존성 처리

## 설정 아키텍처

### 설정 소스
1. **기본 설정**: 내장 기본값
2. **시스템 설정**: 시스템 전체 설정
3. **사용자 설정**: 사용자별 설정
4. **환경 변수**: 런타임 오버라이드
5. **명령줄 인수**: 실행시 오버라이드

### 설정 계층구조
```
명령줄 인수 > 환경변수 > 사용자 설정 > 시스템 설정 > 기본값
```

## 오류 처리 전략

### 오류 범주
1. **시스템 오류**: OS 수준 실패 (권한, 리소스)
2. **프로토콜 오류**: 터미널 프로토콜 위반
3. **설정 오류**: 잘못된 설정 또는 매개변수
4. **플러그인 오류**: 플러그인 로딩 또는 실행 실패
5. **네트워크 오류**: 네트워크 관련 실패

### 오류 처리 패턴
- **우아한 성능 저하**: 기능 축소로 작업 계속
- **재시도 로직**: 일시적 실패에 대한 자동 재시도
- **사용자 알림**: 명확한 오류 메시지 및 복구 안내
- **로깅**: 디버깅을 위한 포괄적인 오류 로깅
- **예외 안전성**: Context manager를 통한 예외 발생 시 리소스 보장 정리
- **RAII 패턴**: 리소스 획득과 동시에 해제 보장

## 보안 고려사항

### 입력 검증
- 모든 사용자 입력의 검증 및 살균
- 인젝션 공격 방지를 위한 ANSI 시퀀스 검증
- 설정 매개변수 검증

### 프로세스 격리
- 자식 프로세스는 적절한 권한으로 실행
- 플러그인 기능 제한을 위한 플러그인 샌드박싱
- 리소스 고갈 방지를 위한 리소스 제한

### 데이터 보호
- 세션 기록에서 민감한 데이터 암호화
- 인증 자격 증명의 안전한 처리
- 개인정보 보호를 고려한 AI 통합 옵션

## 성능 특성

### 예상 성능

#### 성능 목표 (Unix 전용)
- **I/O 지연시간**: < 3ms (uvloop + epoll/kqueue 최적화)
- **처리량**: > 300MB/s (기본 asyncio 대비 3-5배 향상)
- **메모리 사용량**: < 60MB (Unix 메모리 관리 최적화)
- **CPU 사용량**: < 2% (네이티브 Unix I/O 성능)

### 최적화 전략

#### 비동기 I/O 최적화
- **uvloop 활용**: libuv 기반 고성능 이벤트 루프
- **aiofiles 통합**: 비동기 파일 I/O로 블로킹 방지
- **최적화 라이브러리**: Unix 전용 고성능 라이브러리 활용

#### 메모리 및 버퍼 최적화
- **계층적 버퍼링**: 커널 → 애플리케이션 → 사용자 버퍼
- **객체 풀링**: 자주 사용되는 버퍼 객체 재사용
- **적응적 크기**: 워크로드에 따른 동적 버퍼 크기 조정

#### 시그널 및 동시성 최적화
- **aiosignal 통합**: 비동기 시그널 처리로 I/O 블로킹 방지
- **epoll 활용**: Linux/Unix 최적화된 다중 스트림 처리
- **Context manager 최적화**: RAII 패턴으로 리소스 관리 오버헤드 최소화

## 테스트 전략

### 테스트 범주
1. **단위 테스트**: 개별 구성요소 테스트
2. **통합 테스트**: 구성요소 상호작용 테스트
3. **엔드투엔드 테스트**: 전체 워크플로 테스트
4. **성능 테스트**: 성능 및 확장성 테스트
5. **호환성 테스트**: 터미널 애플리케이션 호환성

### 테스트 인프라
- pytest를 사용한 자동화된 테스트
- 테스트 자동화를 통한 지속적 통합
- 성능 벤치마킹 및 회귀 감지
- 플랫폼 간 호환성 테스트

## 지원 플랫폼

### Unix 계열 전용 지원

| 플랫폼 | aiofiles | uvloop | aiosignal | 예상 성능 | 권장 설치 |
|--------|----------|---------|-----------|-----------|-----------|
| **Linux** | ✅ | ✅ | ✅ | 최고 (< 3ms, > 300MB/s) | `uv sync --group performance` |
| **macOS** | ✅ | ✅ | ✅ | 최고 (< 3ms, > 300MB/s) | `uv sync --group performance` |

### Unix 계열 설치 가이드

#### Linux/macOS 전용 설치
```bash
# 전체 성능 최적화 설치
uv sync --group performance

# 환경 확인
python -c "
import sys, uvloop, aiosignal
print(f'플랫폼: {sys.platform}')
print(f'uvloop: {uvloop.__version__}')
print(f'aiosignal: {aiosignal.__version__}')
print('✅ Unix 최적 성능 구성 완료')
"
```

### Unix 전용 최적화 설정

```python
import asyncio
import uvloop

# Unix 전용 최적화 설정
def setup_unix_optimization():
    """비동기 이벤트 루프 최적화 설정"""
    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
    
def get_expected_performance() -> dict:
    """고성능 Unix 예상 성능 지표"""
    return {
        'latency': '<3ms', 
        'throughput': '>300MB/s',
        'memory': '<60MB',
        'cpu': '<2%'
    }

# 사용 예시
setup_unix_optimization()
print(f"예상 성능: {get_expected_performance()}")
```

### 개발 환경 권장사항

#### CI/CD 환경
- **GitHub Actions**: Linux runner에서 `uv sync --group performance`
- **GitLab CI**: Docker 이미지에 uvloop 사전 설치
- **Travis CI**: Linux/macOS 환경에서 테스트

#### 개발자 환경
- **Linux 개발자**: 성능 그룹 필수 설치
- **macOS 개발자**: 성능 그룹 필수 설치
- **Unix 전용 테스트**: 의존성 그룹별 테스트 자동화

이 아키텍처는 Unix 계열 전용 최적화를 통해 최대 성능을 달성하며 견고하고 확장 가능한 터미널 래퍼를 구축하기 위한 견고한 기반을 제공합니다.